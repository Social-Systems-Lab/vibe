<!DOCTYPE html>
<html>
    <head>
        <title>Vibe Hub</title>
        <script src="https://cdn.jsdelivr.net/npm/pouchdb@9.0.0/dist/pouchdb.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/pouchdb@9.0.0/dist/pouchdb.find.min.js"></script>
    </head>
    <body>
        <h1>Vibe Data Hub</h1>
        <script>
            // --- 1. Initialization and State ---
            console.log("Hub script loaded.");

            const permissionsCache = new Map();
            const connectedApps = new Map();
            const db = new PouchDB("vibe-local");
            let remoteDb = null;
            let currentUser = null;
            let syncHandler = null;
            const subscriptions = new Map();

            // --- 2. Main Message Handler ---
            window.addEventListener("message", (event) => {
                // In a real implementation, we would strictly validate event.origin against a list of known apps.
                // For the PoC, we trust the origin that the SDK provides.
                const { type, payload, nonce, origin } = event.data;

                if (type === "INIT") {
                    handleInit(event);
                } else if (type === "GET_USER") {
                    handleGetUser(event);
                } else if (type && type.startsWith("DB_")) {
                    handleDataOperation(event);
                }
            });

            // --- 3. Handlers ---
            async function handleInit(event) {
                const { payload } = event.data;
                const { origin, user, redirectUri } = payload;
                const sourcePort = event.ports[0];

                if (!sourcePort) {
                    console.error("Initialization received without a MessagePort. Aborting.");
                    return;
                }

                if (event.origin !== origin) {
                    console.error(`Origin mismatch! Event came from ${event.origin} but claimed to be ${origin}. Denying connection.`);
                    return;
                }

                try {
                    console.log(`[HUB] Received INIT from claimed origin: ${origin}`);
                    console.log(`[HUB] Verifying against actual event origin: ${event.origin}`);
                    const permissions = await getPermissions(event.origin);
                    console.log(`[HUB] Permissions for ${event.origin}:`, permissions);

                    permissionsCache.set(event.origin, permissions);
                    connectedApps.set(origin, { port: sourcePort, redirectUri });

                    // Listen for messages on the dedicated port
                    sourcePort.onmessage = (event) => {
                        const { type } = event.data;
                        if (type === "GET_USER") {
                            handleGetUser(event);
                        } else if (type && type.startsWith("DB_")) {
                            handleDataOperation(event);
                        } else if (type && type.startsWith("AUTH_")) {
                            handleAuthOperation(event);
                        }
                    };

                    sourcePort.postMessage({ type: "INIT_ACK" });
                    console.log(`Successfully initialized connection for origin: ${origin}`);

                    if (user) {
                        currentUser = user;
                        startSync(user);
                        broadcastAuthStateChange();
                    }
                } catch (error) {
                    console.error(`Failed to initialize connection for origin: ${origin}`, error);
                    sourcePort.postMessage({ type: "INIT_FAIL", error: "Initialization failed." });
                }
            }

            function handleGetUser(event) {
                const sourcePort = connectedApps.get(event.origin);
                if (sourcePort) {
                    sourcePort.postMessage({ type: "GET_USER_ACK", success: true, data: currentUser });
                }
            }

            function handleDataOperation(event) {
                const { type, collection, payload, nonce, subscriptionId } = event.data;
                const origin = event.target.origin || findOriginForPort(event.target);

                if (!origin) {
                    console.error("Could not determine origin for incoming message.");
                    return;
                }

                const sourcePort = connectedApps.get(origin);
                if (!sourcePort) {
                    console.error(`No active port found for origin: ${origin}. Ignoring message.`);
                    return;
                }

                if (type === "DB_SUBSCRIBE") {
                    console.log(`[HUB] Subscription request for ${subscriptionId} from ${origin}`);
                    subscriptions.set(subscriptionId, {
                        collection: payload.collection,
                        filter: payload.filter,
                        port: sourcePort,
                    });
                    return; // No ACK needed for subscriptions
                }

                if (type === "DB_UNSUBSCRIBE") {
                    console.log(`[HUB] Unsubscribe request for ${subscriptionId} from ${origin}`);
                    subscriptions.delete(payload.subscriptionId);
                    return;
                }

                const requiredPermission = `${getScopeForOperation(type)}:${collection}`;
                const appPermissions = permissionsCache.get(origin);

                console.log(`[HUB] Required permission: ${requiredPermission}`);

                // Check for both the specific permission (e.g., "write:posts") and a wildcard (e.g., "write")
                if (appPermissions && appPermissions.scopes && (appPermissions.scopes.includes(requiredPermission) || appPermissions.scopes.includes(getScopeForOperation(type)))) {
                    performPouchDbOperation(type, collection, payload)
                        .then((result) => {
                            sourcePort.postMessage({ type: `${type}_ACK`, success: true, data: result, nonce });
                        })
                        .catch((dbError) => {
                            sourcePort.postMessage({ type: `${type}_ACK`, success: false, error: dbError.message, nonce });
                        });
                } else {
                    console.warn(`Permission denied for origin ${origin} trying to perform ${type}.`);
                    sourcePort.postMessage({ type: `${type}_ACK`, success: false, error: "Permission Denied.", nonce });
                }
            }

            function handleAuthOperation(event) {
                const { type } = event.data;
                const origin = event.target.origin || findOriginForPort(event.target);
                const app = connectedApps.get(origin);

                if (!app) {
                    console.error(`No active port found for origin: ${origin}. Ignoring message.`);
                    return;
                }

                console.log(`[HUB] Received auth operation: ${type} from origin: ${origin}`);
                switch (type) {
                    case "AUTH_LOGIN":
                        const loginUrl = `/auth/authorize?client_id=${encodeURIComponent(origin)}&redirect_uri=${encodeURIComponent(app.redirectUri)}&response_type=code&scope=openid`;
                        console.log(`[HUB] Opening login popup: ${loginUrl}`);
                        window.open(loginUrl, "vibe-login", "width=500,height=600");
                        break;
                    case "AUTH_LOGOUT":
                        currentUser = null;
                        broadcastAuthStateChange();
                        console.log("[HUB] Logging out, redirecting to /auth/logout");
                        window.location.href = "/auth/logout";
                        break;
                    case "AUTH_SIGNUP":
                        const signupUrl = `/auth/authorize?client_id=${encodeURIComponent(origin)}&redirect_uri=${encodeURIComponent(
                            app.redirectUri
                        )}&response_type=code&scope=openid&form_type=signup`;
                        console.log(`[HUB] Opening signup popup: ${signupUrl}`);
                        window.open(signupUrl, "vibe-signup", "width=500,height=600");
                        break;
                    case "AUTH_EXCHANGE_CODE":
                        exchangeCodeForToken(payload.code, app.redirectUri, origin);
                        break;
                }
            }

            function broadcastAuthStateChange() {
                const state = {
                    isLoggedIn: !!currentUser,
                    user: currentUser,
                };
                console.log("[HUB] Broadcasting auth state change:", state);
                for (const app of connectedApps.values()) {
                    app.port.postMessage({ type: "AUTH_STATE_CHANGE", data: state });
                }
            }

            // --- 4. Helper Functions ---
            function findOriginForPort(port) {
                for (const [origin, p] of connectedApps.entries()) {
                    if (p.port === port) {
                        return origin;
                    }
                }
                return null;
            }

            function getScopeForOperation(type) {
                if (type === "DB_WRITE" || type === "DB_REMOVE") return "write";
                if (type === "DB_READ" || type === "DB_QUERY") return "read";
                return null;
            }

            async function performPouchDbOperation(type, collection, payload) {
                console.log(`Performing ${type} on collection '${collection}' with payload:`, payload);
                switch (type) {
                    case "DB_WRITE":
                        if (!payload._id) {
                            payload._id = `${collection}/${Date.now()}-${Math.random().toString(16).slice(2)}`;
                        }
                        return await db.put({ ...payload, collection });
                    case "DB_READ":
                        return await db.get(payload.id);
                    case "DB_QUERY":
                        const result = await db.find({
                            selector: { ...payload, collection: collection },
                        });
                        return result.docs;
                    default:
                        throw new Error(`Unsupported DB operation: ${type}`);
                }
            }

            async function getPermissions(origin) {
                const response = await fetch(`/auth/permissions?origin=${encodeURIComponent(origin)}`, {
                    credentials: "include",
                });
                if (!response.ok) {
                    console.error(`Failed to fetch permissions for origin: ${origin}`);
                    return { scopes: [] };
                }
                return await response.json();
            }

            // The find plugin is automatically registered by its script.

            async function startSync(user) {
                if (syncHandler) {
                    syncHandler.cancel();
                }

                // This is a simplified example. In a real implementation, you would
                // securely get the remote DB URL and credentials from the vibe-cloud-api.
                try {
                    const response = await fetch("/auth/session", { credentials: "include" });
                    if (!response.ok) {
                        throw new Error("Failed to fetch DB session");
                    }
                    const sessionInfo = await response.json();
                    const remoteDbUrl = new URL(`http://localhost:5984/${sessionInfo.dbName}`);
                    remoteDbUrl.username = sessionInfo.username;
                    remoteDbUrl.password = sessionInfo.password;

                    remoteDb = new PouchDB(remoteDbUrl.toString());

                    console.log(`[HUB] Starting sync with ${remoteDbUrl.origin}/${sessionInfo.dbName}`);

                    syncHandler = db
                        .sync(remoteDb, {
                            live: true,
                            retry: true,
                        })
                        .on("change", function (info) {
                            console.log("[HUB] Sync change:", info);
                        })
                        .on("paused", function (err) {
                            console.log("[HUB] Sync paused:", err);
                        })
                        .on("active", function () {
                            console.log("[HUB] Sync active");
                        })
                        .on("denied", function (err) {
                            console.error("[HUB] Sync denied:", err);
                        })
                        .on("complete", function (info) {
                            console.log("[HUB] Sync complete:", info);
                        })
                        .on("error", function (err) {
                            console.error("[HUB] Sync error:", err);
                        });
                } catch (error) {
                    console.error("Failed to start sync:", error);
                }
            }

            console.log("Hub is ready and listening.");

            db.changes({
                since: "now",
                live: true,
                include_docs: true,
            }).on("change", (change) => {
                console.log("[HUB] Local DB change detected:", change.doc);
                // This is a simplified notification system. A real implementation would
                // use a more efficient way to match documents against subscription filters.
                subscriptions.forEach(async (sub, id) => {
                    if (change.doc.collection === sub.collection) {
                        // Re-query to respect the subscription's filter
                        const result = await db.find({
                            selector: { ...sub.filter, collection: sub.collection },
                        });
                        sub.port.postMessage({
                            type: "DB_UPDATE",
                            subscriptionId: id,
                            data: result.docs,
                        });
                    }
                });
            });

            async function exchangeCodeForToken(code, redirectUri, origin) {
                try {
                    const response = await fetch("/auth/token", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            grant_type: "authorization_code",
                            code,
                            redirect_uri: redirectUri,
                            client_id: origin,
                            code_verifier: "dummy", // PKCE is not fully implemented in the hub strategy
                        }),
                    });

                    if (!response.ok) {
                        throw new Error("Failed to exchange code for token");
                    }

                    const tokenData = await response.json();
                    // At this point, the user is authenticated with the API.
                    // We can now fetch the user's profile and update the hub's state.
                    const userResponse = await fetch("/users/me", {
                        headers: { Authorization: `Bearer ${tokenData.access_token}` },
                    });

                    if (!userResponse.ok) {
                        throw new Error("Failed to fetch user profile");
                    }

                    const { user } = await userResponse.json();
                    currentUser = user;
                    startSync(user);
                    broadcastAuthStateChange();
                } catch (error) {
                    console.error("Error exchanging code for token:", error);
                }
            }
        </script>
    </body>
</html>
