<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Vibe Hub</title>
  </head>
  <body>
    <script>
      // Minimal Postgres-only hub: no PouchDB, no CouchDB.
      // Responsibilities:
      // - Bridge between apps and cloud API via postMessage
      // - Silent auth assist (permissions + api-token)
      // - Read/write via API
      // - Global subscribe via WS; per-user subscribe via lightweight polling

      const connectedApps = new Map(); // origin -> { port }
      const permissionsCache = new Map(); // origin -> { scopes: string[] }
      const subscriptions = new Map(); // id -> { port, key }
      const sharedListeners = new Map(); // key -> { cancel, subscribers: Set<id> }
      let currentUser = null;

      // Logging passthrough to parent apps
      const originalConsole = { ...console };
      ["log", "warn", "error", "info", "debug"].forEach((level) => {
        const orig = console[level];
        console[level] = (...args) => {
          try {
            for (const app of connectedApps.values()) {
              app.port.postMessage({ action: "HUB_LOG", data: { level, args } });
            }
          } catch {}
          orig.apply(console, args);
        };
      });

      window.addEventListener("message", (event) => {
        const { action } = event.data || {};
        if (action === "INIT") return handleInit(event);
        if (action === "SET_USER") return handleSetUser(event);
        if (action === "FORCE_REFRESH_PERMISSIONS") return refreshPermissionsFor(event);
        if (action && action.startsWith("DB_")) return handleDataOperation(event);
      });

      async function handleInit(event) {
        const { payload } = event.data || {};
        const { origin } = payload || {};
        const port = event.ports?.[0];
        if (!port) return console.error("INIT without MessagePort");
        if (event.origin !== origin) return console.error("Origin mismatch", event.origin, origin);
        connectedApps.set(origin, { port });

        try {
          const perms = await getPermissions(origin);
          permissionsCache.set(origin, perms);
          port.postMessage({ action: "INIT_ACK", success: true });
        } catch (e) {
          port.postMessage({ action: "INIT_FAIL", success: false, error: String(e?.message || e) });
        }
      }

      async function handleSetUser(event) {
        const user = event.data?.payload || null;
        const origin = event.target?.origin || findOriginForPort(event.target);
        const app = connectedApps.get(origin);
        if (!app) return console.error("SET_USER from unknown origin");
        currentUser = user;
        try {
          const perms = await getPermissions(origin);
          permissionsCache.set(origin, perms);
          broadcastAuthState();
          app.port.postMessage({ action: "SET_USER_ACK", success: true });
        } catch (e) {
          app.port.postMessage({ action: "SET_USER_ACK", success: false, error: String(e?.message || e) });
        }
      }

      async function refreshPermissionsFor(event) {
        const origin = findOriginForPort(event.target);
        if (!origin) return;
        try {
          const perms = await getPermissions(origin);
          permissionsCache.set(origin, perms);
          broadcastAuthState();
        } catch {}
      }

      function broadcastAuthState() {
        const state = { isLoggedIn: !!currentUser, user: currentUser };
        for (const app of connectedApps.values()) {
          app.port.postMessage({ action: "AUTH_STATE_CHANGE", data: state });
        }
      }

      function findOriginForPort(port) {
        for (const [origin, p] of connectedApps.entries()) if (p.port === port) return origin;
        return null;
      }

      function getScopeForOperation(action) {
        if (action === "DB_WRITE" || action === "DB_REMOVE") return "write";
        if (action === "DB_READ" || action === "DB_QUERY" || action === "DB_GLOBAL_QUERY" || action === "DB_GLOBAL_SUBSCRIBE") return "read";
        return null;
      }

      async function handleDataOperation(event) {
        const { action, type, payload, nonce, subscriptionId } = event.data || {};
        const origin = event.target?.origin || findOriginForPort(event.target);
        if (!origin) return console.error("Unknown origin for DB op");
        const app = connectedApps.get(origin);
        if (!app) return console.error("No app port for DB op");
        const port = app.port;

        // Global
        if (action === "DB_GLOBAL_QUERY") {
          return performGlobalQuery(type, payload)
            .then((res) => port.postMessage({ action: "DB_GLOBAL_QUERY_ACK", success: true, data: res, nonce }))
            .catch((err) => port.postMessage({ action: "DB_GLOBAL_QUERY_ACK", success: false, error: String(err?.message || err), nonce }));
        }
        if (action === "DB_GLOBAL_SUBSCRIBE") {
          const key = `global:${type}|${JSON.stringify(payload?.query || {})}`;
          subscriptions.set(subscriptionId, { port, key });
          if (!sharedListeners.has(key)) {
            const listener = createSharedGlobalListener(type, payload?.query || {});
            sharedListeners.set(key, { cancel: () => listener.close && listener.close(), subscribers: new Set([subscriptionId]) });
          } else {
            sharedListeners.get(key).subscribers.add(subscriptionId);
          }
          return;
        }
        if (action === "DB_GLOBAL_UNSUBSCRIBE") {
          const sub = subscriptions.get(subscriptionId);
          if (sub) {
            subscriptions.delete(subscriptionId);
            const sl = sharedListeners.get(sub.key);
            if (sl) {
              sl.subscribers.delete(subscriptionId);
              if (sl.subscribers.size === 0) {
                sl.cancel?.();
                sharedListeners.delete(sub.key);
              }
            }
          }
          return;
        }

        // Permission check
        const scope = getScopeForOperation(action);
        const required = `${scope}:${type}`;
        const perms = permissionsCache.get(origin) || { scopes: [] };
        const allowed = perms.scopes?.includes(required) || perms.scopes?.includes(scope) || perms.scopes?.includes("upload:files");
        if (!allowed) {
          return port.postMessage({ action: `${action}_ACK`, success: false, error: "Permission Denied.", nonce });
        }

        // Per-user operations via API
        try {
          if (action === "DB_WRITE") {
            const res = await apiWrite(type, payload);
            return port.postMessage({ action: "DB_WRITE_ACK", success: true, data: res, nonce });
          }
          if (action === "DB_QUERY") {
            const res = await apiQuery(type, payload || {});
            return port.postMessage({ action: "DB_QUERY_ACK", success: true, data: res, nonce });
          }
          if (action === "DB_READ") {
            const res = await apiQuery(type, { _id: payload?.id });
            return port.postMessage({ action: "DB_READ_ACK", success: true, data: res?.[0] || null, nonce });
          }
          if (action === "DB_REMOVE") {
            return port.postMessage({ action: "DB_REMOVE_ACK", success: false, error: "Remove not implemented", nonce });
          }
        } catch (e) {
          return port.postMessage({ action: `${action}_ACK`, success: false, error: String(e?.message || e), nonce });
        }
      }

      async function getPermissions(origin) {
        const res = await fetch(`/hub/permissions?origin=${encodeURIComponent(origin)}`, { credentials: "include" });
        if (!res.ok) return { scopes: [] };
        return await res.json();
      }

      async function getAccessToken() {
        const res = await fetch("/hub/api-token", { credentials: "include" });
        if (!res.ok) throw new Error("Failed to fetch API token");
        const { token } = await res.json();
        return token;
      }

      async function apiWrite(type, doc) {
        const token = await getAccessToken();
        const resp = await fetch(`/data/types/${encodeURIComponent(type)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify(doc),
        });
        if (!resp.ok) throw new Error(`API Write Error: ${resp.status}`);
        return await resp.json();
      }

      async function apiQuery(type, query) {
        const { expand, ...selector } = query || {};
        const qs = new URLSearchParams();
        if (expand) qs.set("expand", expand.join(","));
        const token = await getAccessToken();
        const resp = await fetch(`/data/types/${encodeURIComponent(type)}/query?${qs.toString()}`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify(selector || {}),
        });
        if (!resp.ok) throw new Error(`API Query Error: ${resp.status}`);
        const result = await resp.json();
        return result.docs || [];
      }

      async function performGlobalQuery(type, payload) {
        const { expand, ...selector } = payload || {};
        const qs = new URLSearchParams({ global: "true" });
        if (expand) qs.set("expand", expand.join(","));
        const token = await getAccessToken();
        const resp = await fetch(`/data/types/${encodeURIComponent(type)}/query?${qs.toString()}`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify(selector || {}),
        });
        if (!resp.ok) throw new Error(`API Global Query Error: ${resp.status}`);
        const result = await resp.json();
        if (!result.docs || result.docs.length === 0) return [];
        const temp = result.docs.map((d) => ({ _id: d._id, ref: d.ref }));
        let full = await _expand(temp, ["ref"]);
        full = full.map((x) => x.ref).filter(Boolean);
        if (expand) full = await _expand(full, expand);
        return full;
      }

      function createSharedGlobalListener(type, query) {
        const wsUrl = window.location.origin.replace(/^http/, "ws");
        const ws = new WebSocket(`${wsUrl}/data/global`);
        let cache = [];
        ws.onopen = async () => {
          const token = await getAccessToken();
          ws.send(JSON.stringify({ action: "auth", token, query: { ...(query || {}), type } }));
        };
        ws.onmessage = async (ev) => {
          const msg = JSON.parse(ev.data);
          const key = `global:${type}|${JSON.stringify(query || {})}`;
          const sl = sharedListeners.get(key);
          if (!sl) return;
          const broadcast = (docs) => {
            sl.subscribers.forEach((sid) => {
              const sub = subscriptions.get(sid);
              if (sub) sub.port.postMessage({ action: "DB_UPDATE", subscriptionId: sid, data: docs });
            });
          };
          if (msg.docs) {
            const temp = msg.docs.map((d) => ({ _id: d._id, ref: d.ref }));
            const expandedRef = await _expand(temp, ["ref"]);
            let full = expandedRef.map((x) => x.ref).filter(Boolean);
            if (query?.expand) full = await _expand(full, query.expand);
            cache = full;
            broadcast(cache);
          } else if (msg.action === "update") {
            const temp = [{ _id: msg.data.ref, ref: msg.data }];
            const expanded = await _expand(temp, ["ref"]);
            const full = expanded[0]?.ref;
            if (full && !cache.some((d) => d._id === full._id)) {
              cache.unshift(full);
              broadcast(cache);
            }
          }
        };
        return ws;
      }

      async function _expand(docs, expand) {
        const expanded = [];
        for (const doc of docs) {
          const newDoc = { ...doc };
          for (const field of expand || []) {
            const v = doc[field];
            if (v && typeof v === "object" && v.ref && v.did) {
              const res = await fetch(`/data/expand?did=${encodeURIComponent(v.did)}&ref=${encodeURIComponent(v.ref)}`);
              if (res.ok) newDoc[field] = await res.json();
            } else if (Array.isArray(v)) {
              const arr = [];
              for (const entry of v) {
                if (entry && entry.ref && entry.did) {
                  const res = await fetch(`/data/expand?did=${encodeURIComponent(entry.did)}&ref=${encodeURIComponent(entry.ref)}`);
                  if (res.ok) arr.push(await res.json()); else arr.push(entry);
                } else {
                  arr.push(entry);
                }
              }
              newDoc[field] = arr;
            }
          }
          expanded.push(newDoc);
        }
        return expanded;
      }

      console.log("Hub ready");
    </script>
  </body>
  </html>

