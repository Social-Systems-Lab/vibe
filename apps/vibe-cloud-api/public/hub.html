<!DOCTYPE html>
<html>
    <head>
        <title>Vibe Hub</title>
        <script src="https://cdn.jsdelivr.net/npm/pouchdb@9.0.0/dist/pouchdb.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/pouchdb@9.0.0/dist/pouchdb.find.min.js"></script>
    </head>
    <body>
        <h1>Vibe Data Hub</h1>
        <script>
            // --- 1. Initialization and State ---
            const permissionsCache = new Map();
            const connectedApps = new Map();
            let db = null;
            let remoteDb = null;
            let currentUser = null;
            let syncHandler = null;
            const subscriptions = new Map();
            const sharedListeners = new Map();
            let dbOperationLock = Promise.resolve(); // Re-introducing the lock as it's the correct pattern.

            // --- 1.2 Shared Worker Initialization ---
            let sharedWorker = null;
            if (window.SharedWorker) {
                console.log("[HUB] Shared Worker is supported. Initializing...");
                sharedWorker = new SharedWorker("shared-worker.js");

                sharedWorker.port.onmessage = (event) => {
                    console.log("[HUB] Received message from Shared Worker:", event.data);
                    // Handle messages from the worker, e.g., forward to the correct app port
                };

                sharedWorker.onerror = (err) => {
                    console.error("[HUB] Shared Worker error:", err);
                };

                // Start the port to allow messages to be received
                sharedWorker.port.start();

                // Test message to see if the connection is working
                sharedWorker.port.postMessage({ type: "HUB_INIT" });
            } else {
                console.warn("[HUB] Shared Worker is not supported in this browser.");
            }

            // --- 1.3 Logging Bridge ---
            const originalConsole = { ...console };
            const logToParent = (level, args) => {
                try {
                    // We need to check if connectedApps is being initialized to avoid errors
                    if (connectedApps && connectedApps.values) {
                        for (const app of connectedApps.values()) {
                            app.port.postMessage({
                                type: "HUB_LOG",
                                data: {
                                    level,
                                    // Ensure args are serializable
                                    args: JSON.parse(JSON.stringify(args)),
                                },
                            });
                        }
                    }
                } catch (error) {
                    // Use original console to avoid infinite loops
                    originalConsole.error("Error posting log to parent:", error);
                }
            };
            const levels = ["log", "warn", "error", "info", "debug"];
            levels.forEach((level) => {
                const originalMethod = console[level];
                console[level] = (...args) => {
                    originalMethod.apply(console, args);
                    logToParent(level, args);
                };
            });

            console.log("Hub script loaded.");

            // --- 2. Main Message Handler ---
            window.addEventListener("message", (event) => {
                // In a real implementation, we would strictly validate event.origin against a list of known apps.
                // For the PoC, we trust the origin that the SDK provides.
                const { type, payload, nonce, origin } = event.data;

                if (type === "INIT") {
                    handleInit(event);
                } else if (type === "GET_USER") {
                    handleGetUser(event);
                } else if (type && type.startsWith("DB_")) {
                    handleDataOperation(event);
                }
            });

            // --- 3. Handlers ---
            async function handleInit(event) {
                const { payload } = event.data;
                const { origin, user, redirectUri } = payload;
                const sourcePort = event.ports[0];

                if (!sourcePort) {
                    console.error("Initialization received without a MessagePort. Aborting.");
                    return;
                }

                if (event.origin !== origin) {
                    console.error(`Origin mismatch! Event came from ${event.origin} but claimed to be ${origin}. Denying connection.`);
                    return;
                }

                try {
                    console.log(`[HUB] Received INIT from claimed origin: ${origin}`);
                    console.log(`[HUB] Verifying against actual event origin: ${event.origin}`);
                    const permissions = await getPermissions(event.origin);
                    console.log(`[HUB] Permissions for ${event.origin}:`, permissions);

                    permissionsCache.set(event.origin, permissions);
                    connectedApps.set(origin, { port: sourcePort, redirectUri });

                    // Listen for messages on the dedicated port
                    sourcePort.onmessage = processMessage;

                    if (user) {
                        currentUser = user;
                        await startSync(user);
                        broadcastAuthStateChange();
                    }

                    sourcePort.postMessage({ type: "INIT_ACK" });
                    console.log(`Successfully initialized connection for origin: ${origin}`);
                } catch (error) {
                    console.error(`Failed to initialize connection for origin: ${origin}`, error);
                    sourcePort.postMessage({ type: "INIT_FAIL", error: "Initialization failed." });
                }
            }

            function handleGetUser(event) {
                const app = connectedApps.get(event.origin);
                if (app) {
                    app.port.postMessage({ type: "GET_USER_ACK", success: true, data: currentUser });
                }
            }

            function processMessage(event) {
                const { type } = event.data;
                if (type === "GET_USER") {
                    handleGetUser(event);
                } else if (type === "SET_USER") {
                    handleSetUser(event);
                } else if (type === "FORCE_REFRESH_PERMISSIONS") {
                    handleForceRefreshPermissions(event);
                } else if (type && type.startsWith("DB_")) {
                    handleDataOperation(event);
                }
            }

            async function updateUserSession(user, origin, forceUpdate = false) {
                let releaseLock;
                dbOperationLock = new Promise((resolve) => (releaseLock = resolve));

                try {
                    console.log(`[HUB] Updating user session for origin: ${origin}`);

                    // 1. Stop any existing sync and clear local DB instance
                    if (syncHandler) {
                        syncHandler.cancel();
                        syncHandler = null;
                    }
                    if (db) {
                        await db.close();
                        db = null;
                    }
                    currentUser = user;

                    // 2. If no user, just update permissions and broadcast.
                    if (!user) {
                        console.log(`[HUB] User logged out. Clearing session for ${origin}`);
                        const permissions = await getPermissions(origin);
                        permissionsCache.set(origin, permissions);
                        broadcastAuthStateChange();
                        return;
                    }

                    // 3. Fetch new permissions and session info in parallel
                    console.log(`[HUB] User set. Re-fetching permissions and session for ${origin}`);
                    const [permissions, sessionInfo] = await Promise.all([getPermissions(origin), getDbSession()]);

                    console.log(`[HUB] New permissions for ${origin}:`, permissions);
                    permissionsCache.set(origin, permissions);

                    // 4. Start the new sync with the fetched session info
                    await startSync(sessionInfo);
                    broadcastAuthStateChange();
                } finally {
                    releaseLock();
                    console.log("[HUB] DB Operation lock released.");
                }
            }

            async function handleSetUser(event) {
                const { payload, nonce } = event.data;
                const user = payload;
                const origin = findOriginForPort(event.target);
                const app = origin ? connectedApps.get(origin) : null;

                if (!app) {
                    console.error("Could not determine origin or app for SET_USER message.");
                    return;
                }

                // The updateUserSession function now handles its own locking.
                updateUserSession(user, origin)
                    .then(() => {
                        app.port.postMessage({ type: "SET_USER_ACK", success: true, nonce });
                    })
                    .catch((error) => {
                        console.error(`[HUB] Error during SET_USER for ${origin}:`, error);
                        app.port.postMessage({ type: "SET_USER_ACK", success: false, error: error.message, nonce });
                    });
            }

            async function handleForceRefreshPermissions(event) {
                const origin = findOriginForPort(event.target);
                if (origin) {
                    console.log(`[HUB] Force-refreshing permissions for origin: ${origin}.`);
                    // We pass the current user to force a refresh of permissions and session.
                    await updateUserSession(currentUser, origin, true);
                }
            }

            async function handleDataOperation(event) {
                await dbOperationLock; // Ensure DB is ready before any data ops
                const { type, collection, payload, nonce, subscriptionId } = event.data;
                const origin = event.target.origin || findOriginForPort(event.target);

                if (!origin) {
                    console.error("Could not determine origin for incoming message.");
                    return;
                }

                const app = connectedApps.get(origin);
                if (!app) {
                    console.error(`No active port found for origin: ${origin}. Ignoring message.`);
                    return;
                }
                const sourcePort = app.port;

                if (type === "DB_SUBSCRIBE") {
                    const { collection, query } = payload;
                    const canonicalKey = `${collection}|${JSON.stringify(query || {})}`;
                    console.log(`[HUB] Subscription request for ${subscriptionId} from ${origin} with key ${canonicalKey}`);

                    subscriptions.set(subscriptionId, {
                        canonicalKey,
                        port: app.port,
                        query: query,
                    });

                    if (!sharedListeners.has(canonicalKey)) {
                        console.log(`[HUB] Creating new shared listener for ${canonicalKey}`);
                        const listener = createSharedListener(collection, query || {});
                        if (listener) {
                            console.log(`[HUB] Shared listener created successfully for ${canonicalKey}`);
                            sharedListeners.set(canonicalKey, {
                                listener,
                                subscribers: new Set([subscriptionId]),
                            });
                        } else {
                            console.error(`[HUB] Failed to create shared listener for ${canonicalKey}`);
                        }
                    } else {
                        console.log(`[HUB] Attaching to existing shared listener for ${canonicalKey}`);
                        sharedListeners.get(canonicalKey).subscribers.add(subscriptionId);
                    }
                    return;
                }

                if (type === "DB_UNSUBSCRIBE") {
                    const { subscriptionId } = payload;
                    console.log(`[HUB] Unsubscribe request for ${subscriptionId} from ${origin}`);
                    const sub = subscriptions.get(subscriptionId);
                    if (sub) {
                        subscriptions.delete(subscriptionId);
                        const sharedListener = sharedListeners.get(sub.canonicalKey);
                        if (sharedListener) {
                            sharedListener.subscribers.delete(subscriptionId);
                            if (sharedListener.subscribers.size === 0) {
                                console.log(`[HUB] Stopping shared listener for ${sub.canonicalKey}`);
                                sharedListener.listener.cancel();
                                sharedListeners.delete(sub.canonicalKey);
                            }
                        }
                    }
                    return;
                }

                if (type === "DB_GLOBAL_QUERY") {
                    console.log(`[HUB] Received DB_GLOBAL_QUERY for collection: ${collection}`, payload);
                    performGlobalQuery(type, collection, payload)
                        .then((result) => {
                            console.log(`[HUB] DB_GLOBAL_QUERY successful, returning ${result.length} docs.`);
                            sourcePort.postMessage({ type: "DB_GLOBAL_QUERY_ACK", success: true, data: result, nonce });
                        })
                        .catch((dbError) => {
                            console.error(`[HUB] DB_GLOBAL_QUERY failed:`, dbError);
                            sourcePort.postMessage({ type: "DB_GLOBAL_QUERY_ACK", success: false, error: dbError.message, nonce });
                        });
                    return;
                }

                if (type === "DB_GLOBAL_SUBSCRIBE") {
                    const { collection, query } = payload;
                    const canonicalKey = `global:${collection}|${JSON.stringify(query || {})}`;
                    console.log(`[HUB] Global subscription request for ${subscriptionId} from ${origin} with key ${canonicalKey}`);

                    subscriptions.set(subscriptionId, {
                        canonicalKey,
                        port: app.port,
                    });

                    if (!sharedListeners.has(canonicalKey)) {
                        console.log(`[HUB] Creating new shared global listener for ${canonicalKey}`);
                        const listener = createSharedGlobalListener(collection, query || {});
                        sharedListeners.set(canonicalKey, {
                            listener,
                            subscribers: new Set([subscriptionId]),
                        });
                    } else {
                        console.log(`[HUB] Attaching to existing shared global listener for ${canonicalKey}`);
                        sharedListeners.get(canonicalKey).subscribers.add(subscriptionId);
                    }
                    return;
                }

                if (type === "DB_GLOBAL_UNSUBSCRIBE") {
                    const { subscriptionId } = payload;
                    console.log(`[HUB] Global unsubscribe request for ${subscriptionId} from ${origin}`);
                    const sub = subscriptions.get(subscriptionId);
                    if (sub) {
                        subscriptions.delete(subscriptionId);
                        const sharedListener = sharedListeners.get(sub.canonicalKey);
                        if (sharedListener) {
                            sharedListener.subscribers.delete(subscriptionId);
                            if (sharedListener.subscribers.size === 0) {
                                console.log(`[HUB] Stopping shared global listener for ${sub.canonicalKey}`);
                                sharedListener.listener.close();
                                sharedListeners.delete(sub.canonicalKey);
                            }
                        }
                    }
                    return;
                }
                const requiredPermission = `${getScopeForOperation(type)}:${collection}`;
                const appPermissions = permissionsCache.get(origin);

                console.log(`[HUB] Required permission: ${requiredPermission}`);

                // Check for both the specific permission (e.g., "write:posts") and a wildcard (e.g., "write")
                if (appPermissions && appPermissions.scopes && (appPermissions.scopes.includes(requiredPermission) || appPermissions.scopes.includes(getScopeForOperation(type)))) {
                    performPouchDbOperation(type, collection, payload)
                        .then((result) => {
                            sourcePort.postMessage({ type: `${type}_ACK`, success: true, data: result, nonce });
                        })
                        .catch((dbError) => {
                            sourcePort.postMessage({ type: `${type}_ACK`, success: false, error: dbError.message, nonce });
                        });
                } else {
                    console.warn(`Permission denied for origin ${origin} trying to perform ${type}.`);
                    sourcePort.postMessage({ type: `${type}_ACK`, success: false, error: "Permission Denied.", nonce });
                }
            }

            function broadcastAuthStateChange() {
                const state = {
                    isLoggedIn: !!currentUser,
                    user: currentUser,
                };
                console.log("[HUB] Broadcasting auth state change:", state);
                for (const app of connectedApps.values()) {
                    app.port.postMessage({ type: "AUTH_STATE_CHANGE", data: state });
                }
            }

            // --- 4. Helper Functions ---
            function findOriginForPort(port) {
                for (const [origin, p] of connectedApps.entries()) {
                    if (p.port === port) {
                        return origin;
                    }
                }
                return null;
            }

            function getScopeForOperation(type) {
                if (type === "DB_WRITE" || type === "DB_REMOVE") return "write";
                if (type === "DB_READ" || type === "DB_QUERY" || type === "DB_GLOBAL_QUERY" || type === "DB_GLOBAL_SUBSCRIBE") return "read";
                return null;
            }

            async function performPouchDbOperation(type, collection, payload) {
                await dbOperationLock; // Wait for any pending db re-initialization to complete
                if (!db) {
                    throw new Error("Database not initialized");
                }
                console.log(`Performing ${type} on collection '${collection}' with payload:`, payload);
                switch (type) {
                    case "DB_WRITE":
                        // Any ACL makes a document globally accessible, so it must be written via the API.
                        const isGloballyAcessible = payload.acl && Object.keys(payload.acl).length > 0;
                        if (isGloballyAcessible) {
                            // If ACL is set, write through the API to trigger global DB logic
                            console.log("[HUB] Writing document with ACL through API.", payload);
                            return await performApiWrite(collection, payload);
                        } else {
                            // Otherwise, write locally for speed
                            console.log("[HUB] Writing document without ACL locally.", payload);
                            if (!payload._id) {
                                payload._id = `${collection}/${Date.now()}-${Math.random().toString(16).slice(2)}`;
                            }
                            return await db.put({ ...payload, collection });
                        }
                    case "DB_READ":
                        return await db.get(payload.id);
                    case "DB_QUERY":
                        const { expand, maxCacheAge, ...selector } = payload;

                        const findResult = await db.find({
                            selector: { ...selector },
                        });

                        if (expand && expand.length > 0) {
                            return await _expand(findResult.docs, expand, maxCacheAge);
                        }

                        console.log(`[HUB] Query successful, received ${findResult.docs?.length || 0} Docs.`);

                        return findResult.docs;
                    case "DB_REMOVE":
                        return await db.remove(payload);
                    default:
                        throw new Error(`Unsupported DB operation: ${type}`);
                }
            }

            async function getPermissions(origin) {
                const response = await fetch(`/hub/permissions?origin=${encodeURIComponent(origin)}`, {
                    credentials: "include",
                });
                if (!response.ok) {
                    console.error(`Failed to fetch permissions for origin: ${origin}`);
                    return { scopes: [] };
                }
                return await response.json();
            }

            // The find plugin is automatically registered by its script.

            async function getDbSession() {
                const response = await fetch("/hub/session", { credentials: "include" });
                if (!response.ok) {
                    throw new Error("Failed to fetch DB session");
                }
                return await response.json();
            }

            async function startSync(sessionInfo) {
                if (!sessionInfo || !sessionInfo.dbName) {
                    console.log("[HUB] No session info provided, skipping sync.");
                    return;
                }
                try {
                    console.log(`[HUB] Creating DB: ${sessionInfo.dbName}`);
                    db = new PouchDB(sessionInfo.dbName);
                    await db.createIndex({
                        index: { fields: ["collection"] },
                    });
                    const remoteDbUrl = new URL(`http://localhost:5984/${sessionInfo.dbName}`);
                    remoteDbUrl.username = sessionInfo.username;
                    remoteDbUrl.password = sessionInfo.password;

                    remoteDb = new PouchDB(remoteDbUrl.toString());

                    console.log(`[HUB] Starting sync with ${remoteDbUrl.origin}/${sessionInfo.dbName}`);

                    syncHandler = db
                        .sync(remoteDb, {
                            live: true,
                            retry: true,
                        })
                        .on("change", function (info) {
                            // console.log("[HUB] Sync change:", info);
                        })
                        .on("paused", function (err) {
                            console.log("[HUB] Sync paused:", err);
                        })
                        .on("active", function () {
                            // console.log("[HUB] Sync active");
                        })
                        .on("denied", function (err) {
                            console.error("[HUB] Sync denied:", err);
                        })
                        .on("complete", function (info) {
                            console.log("[HUB] Sync complete:", info);
                        })
                        .on("error", function (err) {
                            console.error("[HUB] Sync error:", err);
                        });
                    setupDbChangesListener();
                } catch (error) {
                    console.error("Failed to start sync:", error);
                }
            }

            console.log("Hub is ready and listening.");

            function setupDbChangesListener() {
                // This function is now replaced by the dynamic creation of shared listeners.
                // We can remove it or leave it empty. For now, I'll leave it empty.
            }

            function createSharedListener(collection, query) {
                if (!db) return null;

                const changes = db
                    .changes({
                        since: "now",
                        live: true,
                        include_docs: true,
                        selector: { collection: collection },
                    })
                    .on("change", async (change) => {
                        console.log(`[HUB] Change detected for collection ${collection}:`, change.doc);
                        // Find all subscriptions for this collection and notify them.
                        for (const [subId, sub] of subscriptions.entries()) {
                            if (sub.canonicalKey.startsWith(collection + "|")) {
                                console.log(`[HUB] Change matches subscription ${subId}. Re-running query.`);
                                const { expand, maxCacheAge, ...selector } = sub.query;
                                const findResult = await db.find({
                                    selector: { ...selector, collection: collection },
                                });

                                let docs = findResult.docs;
                                if (expand && expand.length > 0) {
                                    docs = await _expand(docs, expand, maxCacheAge);
                                }

                                sub.port.postMessage({
                                    type: "DB_UPDATE",
                                    subscriptionId: subId,
                                    data: docs,
                                });
                            }
                        }
                    });
                return changes;
            }

            async function performGlobalQuery(type, collection, payload) {
                console.log(`[HUB] Performing global query for collection: ${collection}`, payload);
                try {
                    const { expand, ...selector } = payload;
                    const query = new URLSearchParams({
                        global: "true",
                    });
                    if (expand) {
                        query.set("expand", expand.join(","));
                    }
                    const token = await getAccessToken();
                    const response = await fetch(`/data/${collection}/query?${query.toString()}`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${token}`,
                        },
                        body: JSON.stringify(selector),
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`[HUB] Global query API error: ${response.status}`, errorText);
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }

                    const result = await response.json();
                    console.log(`[HUB] Global query successful, received ${result.docs?.length || 0} DocRefs.`);

                    if (result.docs.length === 0) {
                        return [];
                    }

                    // The API now returns DocRefs, so the hub is responsible for expanding them.
                    const tempDocsForExpansion = result.docs.map((doc) => ({ _id: doc._id, ref: doc.ref }));
                    let fullDocs = (await _expand(tempDocsForExpansion, ["ref"])).map((doc) => doc.ref);

                    // Perform the second, explicit expansion if requested
                    if (expand) {
                        fullDocs = await _expand(fullDocs, expand);
                    }

                    return fullDocs;
                } catch (error) {
                    console.error("[HUB] Error in performGlobalQuery:", error);
                    throw error;
                }
            }

            function createSharedGlobalListener(collection, query) {
                const VIBE_WS_URL = window.location.origin.replace(/^http/, "ws");
                const ws = new WebSocket(`${VIBE_WS_URL}/data/global`);
                let cachedDocs = []; // Cache for the documents of this subscription

                ws.onopen = async () => {
                    const token = await getAccessToken();
                    const authMessage = {
                        type: "auth",
                        token: token,
                        query: { ...query, collection },
                    };
                    ws.send(JSON.stringify(authMessage));
                };

                ws.onmessage = (event) => {
                    const messageData = JSON.parse(event.data);
                    const canonicalKey = `global:${collection}|${JSON.stringify(query)}`;
                    const sharedListener = sharedListeners.get(canonicalKey);

                    if (!sharedListener) return;

                    const broadcastUpdate = (docs) => {
                        sharedListener.subscribers.forEach((subId) => {
                            const sub = subscriptions.get(subId);
                            if (sub) {
                                sub.port.postMessage({
                                    type: "DB_UPDATE",
                                    subscriptionId: subId,
                                    data: docs,
                                });
                            }
                        });
                    };

                    if (messageData.docs) {
                        // Initial data load
                        const docRefs = messageData.docs;
                        const tempDocsForExpansion = docRefs.map((doc) => ({ _id: doc._id, ref: doc.ref }));
                        _expand(tempDocsForExpansion, ["ref"])
                            .then((expandedDocRefs) => {
                                const fullDocs = expandedDocRefs.map((doc) => doc.ref).filter(Boolean);
                                const { expand } = query;
                                return expand ? _expand(fullDocs, expand) : fullDocs;
                            })
                            .then((finalDocs) => {
                                cachedDocs = finalDocs;
                                broadcastUpdate(cachedDocs);
                            })
                            .catch((err) => console.error("[HUB] Error expanding initial documents:", err));
                    } else if (messageData.type === "update") {
                        // Incremental update
                        const newDocRef = messageData.data;
                        const tempDocForExpansion = [{ _id: newDocRef.ref, ref: newDocRef }];
                        _expand(tempDocForExpansion, ["ref"])
                            .then((expandedDocs) => {
                                const fullNewDoc = expandedDocs[0]?.ref;
                                if (!fullNewDoc) return;
                                const { expand } = query;
                                return expand ? _expand([fullNewDoc], expand) : [fullNewDoc];
                            })
                            .then((finalNewDocs) => {
                                if (!finalNewDocs || finalNewDocs.length === 0) return;
                                const finalNewDoc = finalNewDocs[0];
                                // Avoid duplicates and add to cache
                                if (!cachedDocs.some((d) => d._id === finalNewDoc._id)) {
                                    cachedDocs.unshift(finalNewDoc); // Add to the beginning
                                    broadcastUpdate(cachedDocs);
                                }
                            })
                            .catch((err) => console.error("[HUB] Error expanding incremental update:", err));
                    }
                };

                return ws;
            }

            async function getAccessToken() {
                const response = await fetch("/hub/api-token", { credentials: "include" });
                if (!response.ok) {
                    throw new Error("Failed to fetch API token");
                }
                const { token } = await response.json();
                return token;
            }

            async function _expand(docs, expand, maxCacheAge) {
                await dbOperationLock; // Wait for the db to be ready.

                const expandOneRef = async (ref) => {
                    if (!ref || !ref.did || !ref.ref) return undefined;

                    // Local-first path
                    if (db && currentUser && ref.did === currentUser.did) {
                        try {
                            return await db.get(ref.ref);
                        } catch (error) {
                            if (error.name !== "not_found") {
                                console.error(`Error fetching local document from PouchDB: ${ref.ref}`, error);
                            }
                        }
                    }

                    // Remote with cache
                    const cacheId = `cache/${ref.did}/${ref.ref}`;
                    let existingCacheItem = null;
                    if (db) {
                        try {
                            existingCacheItem = await db.get(cacheId);
                        } catch (error) {
                            // Ignore not_found errors
                        }
                    }

                    const isCacheFresh = () => {
                        if (!existingCacheItem) return false;
                        if (maxCacheAge === 0) return false; // Force refresh
                        if (maxCacheAge === undefined) return true; // Always fresh if no age specified
                        const age = (Date.now() - existingCacheItem.cachedAt) / 1000;
                        return age <= maxCacheAge;
                    };

                    if (isCacheFresh()) {
                        return existingCacheItem.data;
                    }

                    try {
                        const response = await fetch(`/data/expand?did=${ref.did}&ref=${ref.ref}`);
                        if (response.ok) {
                            const remoteDoc = await response.json();

                            if (db) {
                                const newCacheItem = {
                                    _id: cacheId,
                                    _rev: existingCacheItem?._rev,
                                    type: "cache",
                                    data: remoteDoc,
                                    cachedAt: Date.now(),
                                    originalDid: ref.did,
                                    originalRef: ref.ref,
                                };
                                await db.put(newCacheItem);
                            }
                            return remoteDoc;
                        }
                    } catch (apiError) {
                        console.error(`Failed to fetch expanded document for ${ref.ref}`, apiError);
                    }
                    return undefined;
                };

                const promises = docs.map(async (doc) => {
                    const expandedDoc = { ...doc };
                    for (const field of expand) {
                        const value = doc[field];

                        // Single DocRef
                        if (value && typeof value === "object" && "ref" in value && "did" in value) {
                            const expanded = await expandOneRef(value);
                            if (expanded) expandedDoc[field] = expanded;
                            continue;
                        }

                        // Array of DocRefs
                        if (Array.isArray(value)) {
                            const expandedArray = [];
                            for (const entry of value) {
                                if (entry && typeof entry === "object" && "ref" in entry && "did" in entry) {
                                    const expanded = await expandOneRef(entry);
                                    expandedArray.push(expanded || entry);
                                } else {
                                    expandedArray.push(entry);
                                }
                            }
                            expandedDoc[field] = expandedArray;
                        }
                    }
                    return expandedDoc;
                });
                return Promise.all(promises);
            }

            async function performApiWrite(collection, doc) {
                const token = await getAccessToken();
                const response = await fetch(`/data/${collection}`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify(doc),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Write Error: ${response.status} - ${errorText}`);
                }
                const result = await response.json();
                console.log("[HUB] API write successful:", result);

                if (db && result && result.ok) {
                    console.log("[HUB] Writing to local PouchDB to trigger update.");
                    try {
                        const docToPut = { ...doc, _id: result.id, collection };
                        try {
                            const localDoc = await db.get(result.id);
                            docToPut._rev = localDoc._rev;
                            console.log(`[HUB] Found existing local doc with _rev: ${docToPut._rev}`);
                        } catch (e) {
                            console.log("[HUB] No existing local doc found. Creating new one.");
                        }
                        console.log("[HUB] Putting document to local DB:", docToPut);
                        const putResponse = await db.put(docToPut);
                        console.log("[HUB] Local PouchDB write successful:", putResponse);
                    } catch (e) {
                        console.error("[HUB] Error writing to local PouchDB:", e);
                    }
                }
                return result;
            }
        </script>
        <script>
            async function handleIssueCert(event) {
                const { payload, nonce } = event.data;
                const { targetDid, type, expires } = payload;
                const origin = findOriginForPort(event.target);
                const app = origin ? connectedApps.get(origin) : null;

                if (!app) {
                    console.error("Could not determine origin or app for ISSUE_CERT message.");
                    return;
                }

                try {
                    const token = await getAccessToken();
                    const response = await fetch("/certs/issue", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${token}`,
                        },
                        body: JSON.stringify({ targetDid, type, expires }),
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || "Failed to issue certificate");
                    }
                    if (db) {
                        await db.replicate.from(remoteDb, {
                            doc_ids: [result._id],
                        });
                    }
                    app.port.postMessage({ type: "ISSUE_CERT_ACK", success: true, data: result, nonce });
                } catch (error) {
                    console.error(`[HUB] Error during ISSUE_CERT for ${origin}:`, error);
                    app.port.postMessage({ type: "ISSUE_CERT_ACK", success: false, error: error.message, nonce });
                }
            }
        </script>
    </body>
</html>
