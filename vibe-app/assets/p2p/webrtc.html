<!-- webrtc.html -->
<!DOCTYPE html>
<html>
    <!-- Save without formatting: CTRL+K CTRL+SHIFT+S -->
    <head>
        <script>
            // WebRTC wrapper for Vibe app integration
            const VibeP2P = (function () {
                // Private state
                let peers = new Map(); // Map peerId -> {conn, dataChannel}
                let pendingMessages = new Map(); // Map peerId -> [messages]
                let localPeerId = null;
                let messageListeners = [];
                let connectionListeners = [];
                let disconnectionListeners = [];
                const iceConfig = {
                    iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }],
                };

                // Create a random peer ID for this peer
                function generatePeerId() {
                    return Math.random().toString(36).substring(2, 15);
                }

                // Post messages back to the host app
                function postToApp(action, data) {
                    window.ReactNativeWebView.postMessage(
                        JSON.stringify({
                            action,
                            ...data,
                        })
                    );
                }

                // Create RTCPeerConnection
                function createPeerConnection(peerId) {
                    console.log(`Creating peer connection for ${peerId}`);
                    const conn = new RTCPeerConnection(iceConfig);

                    // Create data channel for messaging
                    const dataChannel = conn.createDataChannel("messages");
                    setupDataChannel(dataChannel, peerId);

                    // Handle ICE candidates
                    conn.onicecandidate = (event) => {
                        if (event.candidate) {
                            // In a real app, these would be sent through a signaling server
                            // For our test app, we'll need to manually exchange these
                            postToApp("iceCandidate", {
                                peerId,
                                candidate: JSON.stringify(event.candidate),
                            });
                        }
                    };

                    // Handle data channels received from the remote peer
                    conn.ondatachannel = (event) => {
                        console.log(`Received data channel from ${peerId}`);
                        setupDataChannel(event.channel, peerId);
                    };

                    // Monitor connection state
                    conn.onconnectionstatechange = () => {
                        console.log(`Connection state with ${peerId} changed to: ${conn.connectionState}`);
                        if (conn.connectionState === "connected") {
                            notifyConnection(peerId);
                        } else if (conn.connectionState === "disconnected" || conn.connectionState === "failed" || conn.connectionState === "closed") {
                            disconnectPeer(peerId);
                        }
                    };

                    // Save the connection
                    peers.set(peerId, { conn, dataChannel: null });

                    return conn;
                }

                // Configure a data channel
                function setupDataChannel(channel, peerId) {
                    channel.onopen = () => {
                        console.log(`Data channel with ${peerId} opened`);
                        // Store the data channel
                        const peer = peers.get(peerId);
                        if (peer) {
                            peer.dataChannel = channel;
                            peers.set(peerId, peer);

                            // Send any pending messages
                            if (pendingMessages.has(peerId)) {
                                const messages = pendingMessages.get(peerId);
                                messages.forEach((msg) => {
                                    channel.send(msg);
                                });
                                pendingMessages.delete(peerId);
                            }
                        }
                    };

                    channel.onclose = () => {
                        console.log(`Data channel with ${peerId} closed`);
                    };

                    channel.onmessage = (event) => {
                        console.log(`Message from ${peerId}: ${event.data}`);
                        notifyMessage(peerId, event.data);
                    };
                }

                // Notify listeners of a new message
                function notifyMessage(peerId, content) {
                    messageListeners.forEach((listener) => {
                        try {
                            listener(peerId, content);
                        } catch (err) {
                            console.error("Error in message listener:", err);
                        }
                    });

                    // Also notify the host app
                    postToApp("message", { peerId, content });
                }

                // Notify listeners of a new connection
                function notifyConnection(peerId) {
                    connectionListeners.forEach((listener) => {
                        try {
                            listener(peerId);
                        } catch (err) {
                            console.error("Error in connection listener:", err);
                        }
                    });

                    // Also notify the host app
                    postToApp("connected", { peerId });
                }

                // Notify listeners of a disconnection
                function notifyDisconnection(peerId) {
                    disconnectionListeners.forEach((listener) => {
                        try {
                            listener(peerId);
                        } catch (err) {
                            console.error("Error in disconnection listener:", err);
                        }
                    });

                    // Also notify the host app
                    postToApp("disconnected", { peerId });
                }

                // Initialize with a new random peer ID
                function initialize() {
                    localPeerId = generatePeerId();
                    postToApp("initialized", { localPeerId });
                    return localPeerId;
                }

                // Create an offer to connect to a peer
                async function connectToPeer(peerId) {
                    if (peers.has(peerId)) {
                        console.log(`Already connected to ${peerId}`);
                        return;
                    }

                    if (peerId === localPeerId) {
                        console.error("Cannot connect to your own peer ID");
                        return;
                    }

                    try {
                        const conn = createPeerConnection(peerId);
                        const offer = await conn.createOffer();
                        await conn.setLocalDescription(offer);

                        // In a real app, the offer would be sent through a signaling server
                        // For our test app, we'll need to manually exchange these
                        postToApp("offer", {
                            peerId,
                            offer: JSON.stringify(conn.localDescription),
                        });
                    } catch (err) {
                        console.error("Error creating connection offer:", err);
                        postToApp("error", {
                            peerId,
                            error: err.message || "Error creating connection",
                        });
                    }
                }

                // Handle an offer from a remote peer
                async function handleOffer(peerId, offerJson) {
                    try {
                        const offer = JSON.parse(offerJson);
                        let conn;

                        if (peers.has(peerId)) {
                            conn = peers.get(peerId).conn;
                        } else {
                            conn = createPeerConnection(peerId);
                        }

                        await conn.setRemoteDescription(new RTCSessionDescription(offer));
                        const answer = await conn.createAnswer();
                        await conn.setLocalDescription(answer);

                        // In a real app, the answer would be sent through a signaling server
                        // For our test app, we'll need to manually exchange these
                        postToApp("answer", {
                            peerId,
                            answer: JSON.stringify(conn.localDescription),
                        });
                    } catch (err) {
                        console.error("Error handling offer:", err);
                        postToApp("error", {
                            peerId,
                            error: err.message || "Error handling offer",
                        });
                    }
                }

                // Handle an answer from a remote peer
                async function handleAnswer(peerId, answerJson) {
                    if (!peers.has(peerId)) {
                        console.error(`No pending connection for peer ${peerId}`);
                        return;
                    }

                    try {
                        const answer = JSON.parse(answerJson);
                        const conn = peers.get(peerId).conn;
                        await conn.setRemoteDescription(new RTCSessionDescription(answer));
                    } catch (err) {
                        console.error("Error handling answer:", err);
                        postToApp("error", {
                            peerId,
                            error: err.message || "Error handling answer",
                        });
                    }
                }

                // Handle an ICE candidate from a remote peer
                function handleIceCandidate(peerId, candidateJson) {
                    if (!peers.has(peerId)) {
                        console.error(`No connection for peer ${peerId}`);
                        return;
                    }

                    try {
                        const candidate = JSON.parse(candidateJson);
                        const conn = peers.get(peerId).conn;
                        conn.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (err) {
                        console.error("Error handling ICE candidate:", err);
                    }
                }

                // Send a message to a peer
                function sendMessage(peerId, message) {
                    if (!peers.has(peerId)) {
                        console.error(`No connection for peer ${peerId}`);
                        return false;
                    }

                    const peer = peers.get(peerId);
                    if (peer.dataChannel && peer.dataChannel.readyState === "open") {
                        peer.dataChannel.send(message);
                        return true;
                    } else {
                        // Queue the message to send once the channel is open
                        if (!pendingMessages.has(peerId)) {
                            pendingMessages.set(peerId, []);
                        }
                        pendingMessages.get(peerId).push(message);
                        return false;
                    }
                }

                // Disconnect from a peer
                function disconnectPeer(peerId) {
                    if (!peers.has(peerId)) {
                        return;
                    }

                    const peer = peers.get(peerId);
                    if (peer.dataChannel) {
                        peer.dataChannel.close();
                    }
                    if (peer.conn) {
                        peer.conn.close();
                    }

                    peers.delete(peerId);
                    pendingMessages.delete(peerId);

                    notifyDisconnection(peerId);
                }

                // Get all connected peers
                function getConnectedPeers() {
                    return Array.from(peers.keys());
                }

                // Add a message listener
                function addMessageListener(listener) {
                    messageListeners.push(listener);
                }

                // Add a connection listener
                function addConnectionListener(listener) {
                    connectionListeners.push(listener);
                }

                // Add a disconnection listener
                function addDisconnectionListener(listener) {
                    disconnectionListeners.push(listener);
                }

                // Public API
                return {
                    initialize,
                    connectToPeer,
                    handleOffer,
                    handleAnswer,
                    handleIceCandidate,
                    sendMessage,
                    disconnectPeer,
                    getConnectedPeers,
                    addMessageListener,
                    addConnectionListener,
                    addDisconnectionListener,
                    get localPeerId() {
                        return localPeerId;
                    },
                };
            })();

            // Start the peer ID at initialization
            document.addEventListener("DOMContentLoaded", () => {
                // Initialize when the page loads
                const peerId = VibeP2P.initialize();
                document.getElementById("status").innerText = `Your Peer ID: ${peerId}`;

                // Set up message handling from the React Native app
                window.addEventListener("message", (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        switch (message.action) {
                            case "connect":
                                VibeP2P.connectToPeer(message.peerId);
                                break;
                            case "disconnect":
                                VibeP2P.disconnectPeer(message.peerId);
                                break;
                            case "sendMessage":
                                VibeP2P.sendMessage(message.peerId, message.content);
                                break;
                            case "handleOffer":
                                VibeP2P.handleOffer(message.peerId, message.offer);
                                break;
                            case "handleAnswer":
                                VibeP2P.handleAnswer(message.peerId, message.answer);
                                break;
                            case "handleIceCandidate":
                                VibeP2P.handleIceCandidate(message.peerId, message.candidate);
                                break;
                        }
                    } catch (err) {
                        console.error("Error handling message from React Native:", err);
                    }
                });
            });
        </script>
    </head>
    <body>
        <div id="status">Initializing P2P...</div>
    </body>
</html>
