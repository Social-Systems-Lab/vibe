/**
 * WebRTCPeer provides a wrapper around the RTCPeerConnection API
 * for easier usage with the Vibe Cloud signaling system.
 */
export class WebRTCPeer {
    private connection: RTCPeerConnection;
    private dataChannel: RTCDataChannel | null = null;
    private remoteDataChannel: RTCDataChannel | null = null;
    private isInitiator: boolean;
    private peerId: string;
    private iceCandidateQueue: RTCIceCandidate[] = [];
    private isConnected: boolean = false;
    
    // Event handlers
    private onDataCallback: ((data: any) => void) | null = null;
    private onConnectedCallback: (() => void) | null = null;
    private onDisconnectedCallback: (() => void) | null = null;
    private onSignalCallback: ((signal: any, type: string) => void) | null = null;
    
    /**
     * Create a new WebRTC peer connection
     * 
     * @param peerId The ID of the remote peer
     * @param config The RTCConfiguration object
     * @param isInitiator Whether this peer is initiating the connection
     */
    constructor(peerId: string, config: RTCConfiguration, isInitiator: boolean = false) {
        this.peerId = peerId;
        this.isInitiator = isInitiator;
        
        // Create the RTCPeerConnection
        this.connection = new RTCPeerConnection(config);
        
        // Set up event handlers
        this.connection.onicecandidate = this.handleIceCandidate.bind(this);
        this.connection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);
        this.connection.ondatachannel = this.handleDataChannel.bind(this);
        
        // If we're the initiator, create the data channel
        if (isInitiator) {
            this.createDataChannel();
        }
    }
    
    /**
     * Handle an ICE candidate generated by our peer connection
     */
    private handleIceCandidate(event: RTCPeerConnectionIceEvent): void {
        if (event.candidate) {
            const signal = {
                type: 'ice-candidate',
                candidate: event.candidate
            };
            
            if (this.onSignalCallback) {
                this.onSignalCallback(signal, 'ice-candidate');
            }
        }
    }
    
    // Renamed method to avoid duplicate implementation
    private handleRemoteIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {
        return this.processIceCandidate(candidate);
    }
    
    /**
     * Handle a change in the ICE connection state
     */
    private handleIceConnectionStateChange(): void {
        const state = this.connection.iceConnectionState;
        console.log(`ICE connection state: ${state}`);
        
        if (state === 'connected' || state === 'completed') {
            if (!this.isConnected) {
                this.isConnected = true;
                if (this.onConnectedCallback) {
                    this.onConnectedCallback();
                }
            }
        } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {
            if (this.isConnected) {
                this.isConnected = false;
                if (this.onDisconnectedCallback) {
                    this.onDisconnectedCallback();
                }
            }
        }
    }
    
    /**
     * Handle an incoming data channel
     */
    private handleDataChannel(event: RTCDataChannelEvent): void {
        this.remoteDataChannel = event.channel;
        this.setupDataChannelHandlers(this.remoteDataChannel);
    }
    
    /**
     * Create a data channel for this peer connection
     */
    private createDataChannel(): void {
        try {
            this.dataChannel = this.connection.createDataChannel('vibeData', {
                ordered: true
            });
            
            this.setupDataChannelHandlers(this.dataChannel);
        } catch (err) {
            console.error('Error creating data channel:', err);
        }
    }
    
    /**
     * Set up event handlers for a data channel
     */
    private setupDataChannelHandlers(channel: RTCDataChannel): void {
        channel.onopen = () => {
            console.log(`Data channel [${channel.label}] opened`);
        };
        
        channel.onclose = () => {
            console.log(`Data channel [${channel.label}] closed`);
        };
        
        channel.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (this.onDataCallback) {
                    this.onDataCallback(data);
                }
            } catch (err) {
                console.error('Error parsing data channel message:', err);
            }
        };
        
        channel.onerror = (error) => {
            console.error(`Data channel error:`, error);
        };
    }
    
    /**
     * Create an SDP offer to send to the remote peer
     */
    async createOffer(): Promise<void> {
        try {
            const offer = await this.connection.createOffer();
            await this.connection.setLocalDescription(offer);
            
            // Send the offer to the remote peer
            if (this.onSignalCallback) {
                this.onSignalCallback(offer, 'offer');
            }
        } catch (err) {
            console.error('Error creating offer:', err);
        }
    }
    
    /**
     * Handle an SDP offer from the remote peer
     */
    async handleOffer(offer: RTCSessionDescriptionInit): Promise<void> {
        try {
            await this.connection.setRemoteDescription(new RTCSessionDescription(offer));
            
            // Create an answer
            const answer = await this.connection.createAnswer();
            await this.connection.setLocalDescription(answer);
            
            // Send the answer to the remote peer
            if (this.onSignalCallback) {
                this.onSignalCallback(answer, 'answer');
            }
            
            // Process any queued ICE candidates
            this.processIceCandidateQueue();
        } catch (err) {
            console.error('Error handling offer:', err);
        }
    }
    
    /**
     * Handle an SDP answer from the remote peer
     */
    async handleAnswer(answer: RTCSessionDescriptionInit): Promise<void> {
        try {
            await this.connection.setRemoteDescription(new RTCSessionDescription(answer));
            
            // Process any queued ICE candidates
            this.processIceCandidateQueue();
        } catch (err) {
            console.error('Error handling answer:', err);
        }
    }
    
    /**
     * Process an ICE candidate from the remote peer
     */
    async processIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {
        try {
            // If we don't have a remote description yet, queue the candidate
            if (!this.connection.remoteDescription) {
                this.iceCandidateQueue.push(new RTCIceCandidate(candidate));
                return;
            }
            
            await this.connection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
            console.error('Error processing ICE candidate:', err);
        }
    }
    
    /**
     * Process any queued ICE candidates
     */
    private async processIceCandidateQueue(): Promise<void> {
        if (this.iceCandidateQueue.length === 0) {
            return;
        }
        
        try {
            for (const candidate of this.iceCandidateQueue) {
                await this.connection.addIceCandidate(candidate);
            }
            
            this.iceCandidateQueue = [];
        } catch (err) {
            console.error('Error processing ICE candidate queue:', err);
        }
    }
    
    /**
     * Handle an incoming signal from the remote peer
     */
    handleSignal(signal: any, type: string): void {
        switch (type) {
            case 'offer':
                this.handleOffer(signal);
                break;
            case 'answer':
                this.handleAnswer(signal);
                break;
            case 'ice-candidate':
                if (signal.candidate) {
                    this.processIceCandidate(signal.candidate);
                }
                break;
            default:
                console.warn(`Unknown signal type: ${type}`);
                break;
        }
    }
    
    /**
     * Send data to the remote peer
     */
    sendData(data: any): boolean {
        const channel = this.dataChannel || this.remoteDataChannel;
        
        if (!channel || channel.readyState !== 'open') {
            console.error('Cannot send data: data channel not open');
            return false;
        }
        
        try {
            const jsonData = JSON.stringify(data);
            channel.send(jsonData);
            return true;
        } catch (err) {
            console.error('Error sending data:', err);
            return false;
        }
    }
    
    /**
     * Set a callback for when data is received
     */
    onData(callback: (data: any) => void): void {
        this.onDataCallback = callback;
    }
    
    /**
     * Set a callback for when the connection is established
     */
    onConnected(callback: () => void): void {
        this.onConnectedCallback = callback;
    }
    
    /**
     * Set a callback for when the connection is disconnected
     */
    onDisconnected(callback: () => void): void {
        this.onDisconnectedCallback = callback;
    }
    
    /**
     * Set a callback for when a signal needs to be sent
     */
    onSignal(callback: (signal: any, type: string) => void): void {
        this.onSignalCallback = callback;
    }
    
    /**
     * Start the connection process
     */
    connect(): void {
        if (this.isInitiator) {
            this.createOffer();
        }
    }
    
    /**
     * Close the connection
     */
    close(): void {
        if (this.dataChannel) {
            this.dataChannel.close();
        }
        
        this.connection.close();
    }
    
    /**
     * Get the ID of the remote peer
     */
    getPeerId(): string {
        return this.peerId;
    }
    
    /**
     * Check if the connection is established
     */
    isActive(): boolean {
        return this.isConnected;
    }
}

export default WebRTCPeer;