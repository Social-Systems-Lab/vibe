// models.ts - Vibe Cloud Models, Types, and Schemas
import { t, type Static, type TSchema } from "elysia";
import type nano from "nano";
import type { DocumentInsertResponse, MaybeDocument } from "nano";

//#region --- Collection Constants ---

export const USERS_COLLECTION = "users" as const;
export const BLOBS_COLLECTION = "blobs" as const;
export const CLAIM_CODES_COLLECTION = "claimCodes" as const;
export const APPS_COLLECTION = "apps" as const;
export const INSTANCES_COLLECTION = "instances" as const; // For tracking provisioned instances

//#endregion

//#region --- Core Database Document Schemas & Types ---

// Define PermissionSetting enum/schema
export const PermissionSettingSchema = t.Enum({ Always: "always", Ask: "ask", Never: "never" }, { description: "Permission setting granted by the user." });
export type PermissionSetting = Static<typeof PermissionSettingSchema>;

// GrantSchema: Map of permissionString -> permissionSetting
export const GrantsSchema = t.Record(t.String({ description: "Permission string e.g., read:notes)" }), PermissionSettingSchema, {
    description: "Map of permission strings to their grant setting for this app.",
});

// Corrected Permission Schema
export interface PermissionUpdateResponse extends CouchDbModificationResponse {} // Alias for CouchDB response - UNCOMMENTED

// Renamed UserSchema to IdentitySchema and merged instance details
export const IdentityInstanceStatusSchema = t.Union(
    [
        t.Literal("pending"),
        t.Literal("provisioning"),
        t.Literal("completed"),
        t.Literal("failed"),
        t.Literal("deprovisioning"),
        t.Literal("deprovisioned"),
        t.Literal("failed_deprovision"),
    ],
    {
        description: "Current status of the instance lifecycle.",
    }
);
export type IdentityInstanceStatus = Static<typeof IdentityInstanceStatusSchema>;

export const IdentitySchema = t.Object({
    _id: t.Optional(t.String()), // Typically `${IDENTITIES_COLLECTION}/${identityDid}`
    _rev: t.Optional(t.String()),
    identityDid: t.String({ description: "The DID of the identity." }), // Renamed from userDid
    isAdmin: t.Boolean({ default: false }),
    tier: t.Optional(t.Number({ default: 0, description: "Identity tier." })),

    // Profile information
    profileName: t.Optional(t.String({ description: "Identity's chosen display name." })),
    profilePictureUrl: t.Optional(t.String({ format: "uri", description: "URL to the identity's profile picture." })),

    // Instance information - tightly coupled
    instanceId: t.Optional(t.String({ description: "Unique identifier for the provisioned Vibe Cloud instance." })),
    instanceStatus: t.Optional(IdentityInstanceStatusSchema),
    instanceUrl: t.Optional(t.String({ format: "uri", description: "URL of the provisioned instance." })),
    instanceCreatedAt: t.Optional(t.String({ format: "date-time", description: "Timestamp of when instance provisioning was initiated." })),
    instanceUpdatedAt: t.Optional(t.String({ format: "date-time", description: "Timestamp of the last instance status update." })),
    instanceErrorDetails: t.Optional(t.String({ description: "Details of the error if instance provisioning/operation failed." })),

    // Original request details for provisioning, might be useful for idempotency or audit
    provisioningRequestDetails: t.Optional(
        t.Object({
            nonce: t.String(),
            timestamp: t.String(),
        })
    ),

    collection: t.Literal(USERS_COLLECTION), // Or rename to IDENTITIES_COLLECTION if DB collection name changes
});
export type Identity = Static<typeof IdentitySchema>;

export const BlobMetadataSchema = t.Object({
    _id: t.String(), // Required: objectId (UUID for the blob)
    _rev: t.Optional(t.String()),
    originalFilename: t.String(),
    contentType: t.String(),
    size: t.Number(),
    ownerDid: t.String(),
    uploadTimestamp: t.String({ format: "date-time" }), // ISO date-time string
    bucket: t.String(), // e.g., S3 bucket name
    collection: t.Literal(BLOBS_COLLECTION),
});
export type BlobMetadata = Static<typeof BlobMetadataSchema>; // Single definition derived from schema

export const ClaimCodeSchema = t.Object({
    _id: t.String(), // Required: e.g., "INITIAL_ADMIN" or UUID
    _rev: t.Optional(t.String()),
    code: t.String(),
    expiresAt: t.Nullable(t.String({ format: "date-time" })),
    forDid: t.Nullable(t.String()),
    spentAt: t.Nullable(t.String({ format: "date-time" })),
    claimedByDid: t.Optional(t.String()),
    collection: t.Literal(CLAIM_CODES_COLLECTION),
});
export type ClaimCode = Static<typeof ClaimCodeSchema>;

// Schema for storing User-Specific App Registrations in the database
// _id format: apps/{userDid}/{appId}
export const AppSchema = t.Object({
    _id: t.Optional(t.String()), // Optional: Generated by DB or derived
    _rev: t.Optional(t.String()),
    userDid: t.String(), // DID of the user who registered/consented
    appId: t.String(), // App ID (matches X-Vibe-App-ID header)
    name: t.String(),
    description: t.Optional(t.String()),
    pictureUrl: t.Optional(t.String({ format: "uri" })),
    permissions: t.Array(t.String()), // Permissions requested by this version of the manifest
    grants: GrantsSchema, // Grants given by this specific user for this app
    registeredAt: t.String({ format: "date-time" }), // When the user first registered/consented
    grantsUpdatedAt: t.String({ format: "date-time" }), // When the grants were last updated
    collection: t.Literal(APPS_COLLECTION),
});
export type App = Static<typeof AppSchema>;

// Generic schema for user data documents (non-system collections)
export const GenericDataDocumentSchema = t.Object(
    {
        _id: t.Optional(t.String()),
        _rev: t.Optional(t.String()),
        collection: t.String(), // Collection name (not a system collection)
        // No specific fields defined, allowing any additional properties
    },
    { additionalProperties: true } // Explicitly allow extra fields
);
export type GenericDataDocument = Static<typeof GenericDataDocumentSchema>;

//#endregion

//#region --- API Data Transfer Objects (DTOs) / View Models ---

// Schema for the /data/read endpoint body
export const ReadPayloadSchema = t.Object({
    collection: t.String({ minLength: 1, error: "Collection name is required." }),
    filter: t.Optional(
        t.Record(t.String(), t.Unknown(), {
            error: "Filter must be an object.",
        })
    ),
});
export type ReadPayload = Static<typeof ReadPayloadSchema>;

// Schema for the /data/write endpoint body
// Allows either a single object or an array of objects for the 'data' field
const ArbitraryObjectSchema = t.Record(t.String(), t.Unknown(), { description: "Represents an object with any properties." });
export const WritePayloadSchema = t.Object({
    collection: t.String({ minLength: 1, error: "Collection name is required." }),
    data: t.Union([ArbitraryObjectSchema, t.Array(ArbitraryObjectSchema)], {
        error: "Data must be a single object or an array of objects.",
    }),
});
export type WritePayload = Static<typeof WritePayloadSchema>;

// Response type for successful updates/inserts (can be reused)
export interface CouchDbModificationResponse extends DocumentInsertResponse {}
export interface PermissionUpdateResponse extends CouchDbModificationResponse {} // Uncommented

// --- Elysia Validation Schemas & Derived Types (for API Payloads/Params) ---
// Schemas used for validating API request bodies, query params, etc.

// Generic Data Schemas (for API interaction)
export const GenericDataPayloadSchema = t.Object({}, { additionalProperties: true });
export type GenericDataPayload = Static<typeof GenericDataPayloadSchema>;

// Schema for updating generic documents
export const UpdateDataPayloadSchema = t.Intersect([
    t.Object({
        _rev: t.String({ error: "Missing required field: _rev" }),
    }),
    GenericDataPayloadSchema,
]);
export type UpdateDataPayload = Static<typeof UpdateDataPayloadSchema>;

export const DeleteParamsSchema = t.Object({
    _rev: t.String({ error: "Missing required query parameter: _rev" }),
});
export type DeleteParams = Static<typeof DeleteParamsSchema>;

// Auth Schemas
export const AuthCredentialsSchema = t.Object({
    email: t.String({ format: "email", error: "Invalid email format." }),
    password: t.String({ minLength: 8, error: "Password must be at least 8 characters long." }),
});
export type AuthCredentials = Static<typeof AuthCredentialsSchema>;

export const JWTPayloadSchema = t.Object(
    {
        identityDid: t.String(), // Renamed from userDid
        isAdmin: t.Boolean({ default: false }),
    },
    {
        additionalProperties: true,
        description: "Schema for JWT payload, requires identityDid and isAdmin flag, allows standard claims.",
    }
);
export type JWTPayload = Static<typeof JWTPayloadSchema>;

// --- Auth Schemas ---
export const LoginRequestSchema = t.Object({
    did: t.String({ description: "Identity's DID for authentication." }),
    nonce: t.String({ description: "Client-generated nonce." }),
    timestamp: t.String({ format: "date-time", description: "Client-generated timestamp." }),
    signature: t.String({ description: "Base64 encoded signature of {did}|{nonce}|{timestamp}." }),
});
export type LoginRequest = Static<typeof LoginRequestSchema>;

export const LoginResponseSchema = t.Object({
    token: t.String(),
    identityDid: t.String(),
    isAdmin: t.Boolean(),
});
export type LoginResponse = Static<typeof LoginResponseSchema>;

export const RegisterRequestSchema = t.Object({
    did: t.String({ description: "Identity's DID." }),
    nonce: t.String({ description: "Client-generated nonce." }),
    timestamp: t.String({ format: "date-time", description: "Client-generated timestamp." }),
    signature: t.String({ description: "Base64 encoded signature of {did}|{nonce}|{timestamp}|{claimCode?}." }), // Signature covers claimCode if present
    profileName: t.Optional(t.String()),
    profilePictureUrl: t.Optional(t.String({ format: "uri" })),
    claimCode: t.Optional(t.String({ description: "Optional claim code for admin promotion." })),
});
export type RegisterRequest = Static<typeof RegisterRequestSchema>;

// Register response could be the full Identity object or a subset + token
export const RegisterResponseSchema = t.Object({
    identity: IdentitySchema,
    token: t.String({ description: "JWT token for the newly registered identity." }),
});
export type RegisterResponse = Static<typeof RegisterResponseSchema>;

// --- Identity Schemas (for API interaction) ---

// For GET /identities (Admin) - returns an array of full Identity objects
export const IdentityListResponseSchema = t.Array(IdentitySchema);
export type IdentityListResponse = Static<typeof IdentityListResponseSchema>;

// For GET /identities/:did/status (Anyone)
export const IdentityStatusResponseSchema = t.Object({
    isActive: t.Boolean(),
    // Optionally include instance status if known and public
    instanceStatus: t.Optional(IdentityInstanceStatusSchema),
});
export type IdentityStatusResponse = Static<typeof IdentityStatusResponseSchema>;

// For GET /identities/:did (Admin or Owner) - returns full Identity object
// IdentitySchema itself can be used as the response schema.

// For PUT /identities/:did
export const UpdateIdentityOwnerRequestSchema = t.Object({
    profileName: t.Optional(t.String()),
    profilePictureUrl: t.Optional(t.String({ format: "uri" })),
    claimCode: t.Optional(t.String({ description: "Claim code for admin promotion." })),
    // Owner should sign the update request payload
    nonce: t.String(),
    timestamp: t.String({ format: "date-time" }),
    signature: t.String({ description: "Signature of the update payload by the owner." }),
});
export type UpdateIdentityOwnerRequest = Static<typeof UpdateIdentityOwnerRequestSchema>;

export const UpdateIdentityAdminRequestSchema = t.Partial(
    // Admins can update most fields
    t.Pick(IdentitySchema, [
        "isAdmin",
        "tier",
        "profileName",
        "profilePictureUrl",
        "instanceStatus",
        "instanceUrl",
        "instanceErrorDetails",
        // instanceId should generally not be changed post-creation by admin directly, managed by provisioning flow
    ]),
    { additionalProperties: false } // No other fields allowed for admin update via this schema
);
export type UpdateIdentityAdminRequest = Static<typeof UpdateIdentityAdminRequestSchema>;

export const UpdateIdentityInternalRequestSchema = t.Object({
    // For provisioning script callback
    instanceStatus: IdentityInstanceStatusSchema,
    instanceUrl: t.Optional(t.String({ format: "uri" })),
    instanceErrorDetails: t.Optional(t.String()),
});
export type UpdateIdentityInternalRequest = Static<typeof UpdateIdentityInternalRequestSchema>;

// Response for PUT /identities/:did is the updated IdentitySchema object.

// Admin Claim Schema (still used for initial bootstrap if env var is set)
export const AdminClaimSchema = t.Object({
    did: t.String({ error: "Missing required field: did" }),
    claimCode: t.String({ error: "Missing required field: claimCode" }),
    signature: t.String({ error: "Missing required field: signature (Base64)" }),
});
export type AdminClaimBody = Static<typeof AdminClaimSchema>;

// Blob Schemas (for API interaction) - Unchanged for now
export const BlobUploadBodySchema = t.Object({
    file: t.File({ error: "File upload is required." }),
});
export type BlobUploadBody = Static<typeof BlobUploadBodySchema>;

export const BlobDownloadResponseSchema = t.Object({
    url: t.String({ format: "uri", error: "Invalid URL format." }),
});
export type BlobDownloadResponse = Static<typeof BlobDownloadResponseSchema>;

// App Registration Schemas (for API interaction)
export const AppManifestSchema = t.Object({
    appId: t.String({ minLength: 1, description: "Unique identifier for the app (e.g., URL or reverse domain)" }),
    name: t.String({ minLength: 1, description: "Display name of the app" }),
    description: t.Optional(t.String()),
    pictureUrl: t.Optional(t.String({ format: "uri" })),
    permissions: t.Array(t.String(), { description: "Array of permission strings requested (e.g., 'read:notes')" }),
});
export type AppManifest = Static<typeof AppManifestSchema>; // Renamed for clarity

// Schema for the /apps/upsert endpoint body
export const AppUpsertPayloadSchema = t.Intersect([
    AppManifestSchema, // Includes appId, name, description, pictureUrl, permissions
    t.Object({
        grants: GrantsSchema, // The grants being set/updated by the user
    }),
]);
export type AppUpsertPayload = Static<typeof AppUpsertPayloadSchema>;

// Schema for the /apps/status endpoint response
export const AppStatusResponseSchema = t.Object({
    isRegistered: t.Boolean(),
    manifest: t.Optional(AppManifestSchema), // The manifest version the user last consented to
    grants: t.Optional(GrantsSchema), // The grants the user has given
});
export type AppStatusResponse = Static<typeof AppStatusResponseSchema>;

// Schema for setting app grants via API (KEEPING for potential direct grant updates if needed later, but upsert is primary)
export const SetAppGrantsPayloadSchema = t.Object({
    appId: t.String({ description: "The ID of the application whose grants are being set." }),
    grants: GrantsSchema, // Use the existing GrantsSchema directly
});
export type SetAppGrantsPayload = Static<typeof SetAppGrantsPayloadSchema>;

// Error Schema
export const ErrorResponseSchema = t.Object({
    error: t.String(),
});
export type ErrorResponse = Static<typeof ErrorResponseSchema>;

// Provisioning Schemas (Now part of Identity or removed)
// InstanceSchema is removed as its fields are merged into IdentitySchema.
// INSTANCES_COLLECTION constant might be removed if not used for a separate DB collection anymore.
// ProvisionInstanceRequestSchema is replaced by RegisterRequestSchema.
// ProvisionInstanceResponseSchema is replaced by RegisterResponseSchema.
// InstanceStatusResponseSchema is replaced by fields in IdentitySchema or specific parts of IdentityStatusResponseSchema.
// InternalProvisionUpdateRequestSchema is replaced by UpdateIdentityInternalRequestSchema.
// InstanceListResponseSchema is replaced by IdentityListResponseSchema.

// --- Identity Recovery Schemas --- (Now part of general Identity Schemas)
// IdentityStatusResponseSchema is updated above.
// IdentityMetadataResponseSchema is covered by returning the IdentitySchema object.
// UpdateProfileRequestSchema is part of UpdateIdentityOwnerRequestSchema.

//#endregion

//#region --- WebSocket Types ---

export interface WebSocketAuthContext {
    userDid: string;
    appId: string; // App ID (URL or DID) that initiated the WebSocket connection
}

export interface WebSocketManagedContext extends WebSocketAuthContext {
    subscriptions: Set<string>; // Collections the user is subscribed to
}

export interface WebSocketClientMessage {
    action: "subscribe" | "unsubscribe";
    collection: string;
}

export type WebSocketServerMessage =
    | { status: "subscribed" | "unsubscribed" | "denied" | "not_subscribed"; collection: string; reason?: string }
    | { error: string }
    | { type: "update" | "delete"; collection: string; data: any }; // Consider typing 'data' more strictly

//#endregion

//#region --- Base & External Types ---

export type { DocumentInsertResponse, MaybeDocument };
export type ChangeWithDoc<TDocSchema extends TSchema> = nano.DatabaseChangesResultItem & {
    doc?: Static<TDocSchema> & MaybeDocument; // Ensure _id/_rev might be present
};

//#endregion
