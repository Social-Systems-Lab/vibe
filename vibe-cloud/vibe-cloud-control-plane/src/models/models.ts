// models.ts - Vibe Cloud Models, Types, and Schemas
import { t, type Static, type TSchema } from "elysia";
import type nano from "nano";
import type { DocumentInsertResponse, MaybeDocument } from "nano";

//#region --- Collection Constants ---

export const USERS_COLLECTION = "users" as const;
export const BLOBS_COLLECTION = "blobs" as const;
export const CLAIM_CODES_COLLECTION = "claimCodes" as const;
export const APPS_COLLECTION = "apps" as const;
export const INSTANCES_COLLECTION = "instances" as const; // For tracking provisioned instances

//#endregion

//#region --- Core Database Document Schemas & Types ---

// Define PermissionSetting enum/schema
export const PermissionSettingSchema = t.Enum({ Always: "always", Ask: "ask", Never: "never" }, { description: "Permission setting granted by the user." });
export type PermissionSetting = Static<typeof PermissionSettingSchema>;

// GrantSchema: Map of permissionString -> permissionSetting
export const GrantsSchema = t.Record(t.String({ description: "Permission string e.g., read:notes)" }), PermissionSettingSchema, {
    description: "Map of permission strings to their grant setting for this app.",
});

// Corrected Permission Schema
export interface PermissionUpdateResponse extends CouchDbModificationResponse {} // Alias for CouchDB response - UNCOMMENTED

export const UserSchema = t.Object({
    _id: t.Optional(t.String()),
    _rev: t.Optional(t.String()),
    userDid: t.String(),
    isAdmin: t.Boolean(),
    tier: t.Optional(t.Number({ default: 0, description: "User tier, e.g., 0 for standard, higher for privileged." })),
    instanceId: t.Optional(t.String({ description: "Identifier of the Vibe Cloud instance provisioned for this user." })),
    collection: t.Literal(USERS_COLLECTION),
});
export type User = Static<typeof UserSchema>;

export const BlobMetadataSchema = t.Object({
    _id: t.String(), // Required: objectId (UUID for the blob)
    _rev: t.Optional(t.String()),
    originalFilename: t.String(),
    contentType: t.String(),
    size: t.Number(),
    ownerDid: t.String(),
    uploadTimestamp: t.String({ format: "date-time" }), // ISO date-time string
    bucket: t.String(), // e.g., S3 bucket name
    collection: t.Literal(BLOBS_COLLECTION),
});
export type BlobMetadata = Static<typeof BlobMetadataSchema>; // Single definition derived from schema

export const ClaimCodeSchema = t.Object({
    _id: t.String(), // Required: e.g., "INITIAL_ADMIN" or UUID
    _rev: t.Optional(t.String()),
    code: t.String(),
    expiresAt: t.Nullable(t.String({ format: "date-time" })),
    forDid: t.Nullable(t.String()),
    spentAt: t.Nullable(t.String({ format: "date-time" })),
    claimedByDid: t.Optional(t.String()),
    collection: t.Literal(CLAIM_CODES_COLLECTION),
});
export type ClaimCode = Static<typeof ClaimCodeSchema>;

// Schema for storing User-Specific App Registrations in the database
// _id format: apps/{userDid}/{appId}
export const AppSchema = t.Object({
    _id: t.Optional(t.String()), // Optional: Generated by DB or derived
    _rev: t.Optional(t.String()),
    userDid: t.String(), // DID of the user who registered/consented
    appId: t.String(), // App ID (matches X-Vibe-App-ID header)
    name: t.String(),
    description: t.Optional(t.String()),
    pictureUrl: t.Optional(t.String({ format: "uri" })),
    permissions: t.Array(t.String()), // Permissions requested by this version of the manifest
    grants: GrantsSchema, // Grants given by this specific user for this app
    registeredAt: t.String({ format: "date-time" }), // When the user first registered/consented
    grantsUpdatedAt: t.String({ format: "date-time" }), // When the grants were last updated
    collection: t.Literal(APPS_COLLECTION),
});
export type App = Static<typeof AppSchema>;

// Generic schema for user data documents (non-system collections)
export const GenericDataDocumentSchema = t.Object(
    {
        _id: t.Optional(t.String()),
        _rev: t.Optional(t.String()),
        collection: t.String(), // Collection name (not a system collection)
        // No specific fields defined, allowing any additional properties
    },
    { additionalProperties: true } // Explicitly allow extra fields
);
export type GenericDataDocument = Static<typeof GenericDataDocumentSchema>;

//#endregion

//#region --- API Data Transfer Objects (DTOs) / View Models ---

// Schema for the /data/read endpoint body
export const ReadPayloadSchema = t.Object({
    collection: t.String({ minLength: 1, error: "Collection name is required." }),
    filter: t.Optional(
        t.Record(t.String(), t.Unknown(), {
            error: "Filter must be an object.",
        })
    ),
});
export type ReadPayload = Static<typeof ReadPayloadSchema>;

// Schema for the /data/write endpoint body
// Allows either a single object or an array of objects for the 'data' field
const ArbitraryObjectSchema = t.Record(t.String(), t.Unknown(), { description: "Represents an object with any properties." });
export const WritePayloadSchema = t.Object({
    collection: t.String({ minLength: 1, error: "Collection name is required." }),
    data: t.Union([ArbitraryObjectSchema, t.Array(ArbitraryObjectSchema)], {
        error: "Data must be a single object or an array of objects.",
    }),
});
export type WritePayload = Static<typeof WritePayloadSchema>;

// Response type for successful updates/inserts (can be reused)
export interface CouchDbModificationResponse extends DocumentInsertResponse {}
export interface PermissionUpdateResponse extends CouchDbModificationResponse {} // Uncommented

// --- Elysia Validation Schemas & Derived Types (for API Payloads/Params) ---
// Schemas used for validating API request bodies, query params, etc.

// Generic Data Schemas (for API interaction)
export const GenericDataPayloadSchema = t.Object({}, { additionalProperties: true });
export type GenericDataPayload = Static<typeof GenericDataPayloadSchema>;

// Schema for updating generic documents
export const UpdateDataPayloadSchema = t.Intersect([
    t.Object({
        _rev: t.String({ error: "Missing required field: _rev" }),
    }),
    GenericDataPayloadSchema,
]);
export type UpdateDataPayload = Static<typeof UpdateDataPayloadSchema>;

export const DeleteParamsSchema = t.Object({
    _rev: t.String({ error: "Missing required query parameter: _rev" }),
});
export type DeleteParams = Static<typeof DeleteParamsSchema>;

// Auth Schemas
export const AuthCredentialsSchema = t.Object({
    email: t.String({ format: "email", error: "Invalid email format." }),
    password: t.String({ minLength: 8, error: "Password must be at least 8 characters long." }),
});
export type AuthCredentials = Static<typeof AuthCredentialsSchema>;

export const JWTPayloadSchema = t.Object(
    {
        userDid: t.String(),
    },
    {
        // Allow standard JWT claims like iat, exp, aud, iss etc.
        additionalProperties: true,
        description: "Schema for JWT payload, requires userDid, allows standard claims.",
    }
);
export type JWTPayload = Static<typeof JWTPayloadSchema>;

// Admin Claim Schema
export const AdminClaimSchema = t.Object({
    did: t.String({ error: "Missing required field: did" }),
    claimCode: t.String({ error: "Missing required field: claimCode" }),
    signature: t.String({ error: "Missing required field: signature (Base64)" }),
});
export type AdminClaimBody = Static<typeof AdminClaimSchema>;

// Blob Schemas (for API interaction)
export const BlobUploadBodySchema = t.Object({
    file: t.File({ error: "File upload is required." }),
});
export type BlobUploadBody = Static<typeof BlobUploadBodySchema>;

export const BlobDownloadResponseSchema = t.Object({
    url: t.String({ format: "uri", error: "Invalid URL format." }),
});
export type BlobDownloadResponse = Static<typeof BlobDownloadResponseSchema>;

// App Registration Schemas (for API interaction)
export const AppManifestSchema = t.Object({
    appId: t.String({ minLength: 1, description: "Unique identifier for the app (e.g., URL or reverse domain)" }),
    name: t.String({ minLength: 1, description: "Display name of the app" }),
    description: t.Optional(t.String()),
    pictureUrl: t.Optional(t.String({ format: "uri" })),
    permissions: t.Array(t.String(), { description: "Array of permission strings requested (e.g., 'read:notes')" }),
});
export type AppManifest = Static<typeof AppManifestSchema>; // Renamed for clarity

// Schema for the /apps/upsert endpoint body
export const AppUpsertPayloadSchema = t.Intersect([
    AppManifestSchema, // Includes appId, name, description, pictureUrl, permissions
    t.Object({
        grants: GrantsSchema, // The grants being set/updated by the user
    }),
]);
export type AppUpsertPayload = Static<typeof AppUpsertPayloadSchema>;

// Schema for the /apps/status endpoint response
export const AppStatusResponseSchema = t.Object({
    isRegistered: t.Boolean(),
    manifest: t.Optional(AppManifestSchema), // The manifest version the user last consented to
    grants: t.Optional(GrantsSchema), // The grants the user has given
});
export type AppStatusResponse = Static<typeof AppStatusResponseSchema>;

// Schema for setting app grants via API (KEEPING for potential direct grant updates if needed later, but upsert is primary)
export const SetAppGrantsPayloadSchema = t.Object({
    appId: t.String({ description: "The ID of the application whose grants are being set." }),
    grants: GrantsSchema, // Use the existing GrantsSchema directly
});
export type SetAppGrantsPayload = Static<typeof SetAppGrantsPayloadSchema>;

// Error Schema
export const ErrorResponseSchema = t.Object({
    error: t.String(),
});
export type ErrorResponse = Static<typeof ErrorResponseSchema>;

// Provisioning Schemas

// Schema for documents in the INSTANCES_COLLECTION
export const InstanceSchema = t.Object({
    _id: t.String({ description: "Instance identifier, typically derived from user DID." }), // instanceIdentifier becomes the _id
    _rev: t.Optional(t.String()),
    userDid: t.String({ description: "DID of the user this instance belongs to." }),
    status: t.Union([t.Literal("pending"), t.Literal("provisioning"), t.Literal("completed"), t.Literal("failed")], {
        description: "Current status of the instance provisioning.",
    }),
    instanceUrl: t.Optional(t.String({ format: "uri", description: "URL of the provisioned instance, available when status is 'completed'." })),
    createdAt: t.String({ format: "date-time", description: "Timestamp of when the provisioning request was initiated." }),
    updatedAt: t.Optional(t.String({ format: "date-time", description: "Timestamp of the last status update." })),
    errorDetails: t.Optional(t.String({ description: "Details of the error if provisioning failed." })),
    requestDetails: t.Optional(
        t.Object({
            // Store the request details for auditing/replay prevention
            nonce: t.String(),
            timestamp: t.String(),
        })
    ),
    collection: t.Literal(INSTANCES_COLLECTION),
});
export type Instance = Static<typeof InstanceSchema>;

// Schema for the new user-driven provisioning request
export const ProvisionInstanceRequestSchema = t.Object({
    did: t.String({ description: "User's DID for authentication." }),
    nonce: t.String({ description: "Client-generated nonce for replay protection." }),
    timestamp: t.String({ format: "date-time", description: "Client-generated timestamp for the request." }),
    signature: t.String({ description: "Base64 encoded signature of {did, nonce, timestamp}." }),
});
export type ProvisionInstanceRequest = Static<typeof ProvisionInstanceRequestSchema>;

// Schema for the 202 Accepted response from instance provisioning
export const ProvisionInstanceResponseSchema = t.Object({
    message: t.String(),
    instanceIdentifier: t.String(),
});
export type ProvisionInstanceResponse = Static<typeof ProvisionInstanceResponseSchema>;

// Schema for the instance status endpoint response
export const InstanceStatusResponseSchema = t.Object({
    instanceIdentifier: t.String(),
    userDid: t.String(),
    status: t.String(), // Should match one of the InstanceSchema status literals
    instanceUrl: t.Optional(t.String({ format: "uri" })),
    createdAt: t.String({ format: "date-time" }),
    updatedAt: t.Optional(t.String({ format: "date-time" })),
    errorDetails: t.Optional(t.String()),
});
export type InstanceStatusResponse = Static<typeof InstanceStatusResponseSchema>;

// Schema for the internal callback to update provisioning status
export const InternalProvisionUpdateRequestSchema = t.Object({
    instanceIdentifier: t.String(),
    status: t.Union([t.Literal("completed"), t.Literal("failed")]),
    url: t.Optional(t.String({ format: "uri" })), // Required if status is 'completed'
    error: t.Optional(t.String()), // Required if status is 'failed'
});
export type InternalProvisionUpdateRequest = Static<typeof InternalProvisionUpdateRequestSchema>;

// This is the old admin-only provisioning request schema, can be removed or kept if admin provisioning is still needed.
// For now, let's comment it out as the primary flow is user-driven.
// export const ProvisionRequestSchema = t.Object({
//     targetUserDid: t.String({ description: "The DID of the user for whom the instance is being provisioned." }),
//     instanceIdentifier: t.String({ description: "A unique identifier for the new instance (e.g., subdomain part)." }),
// });
// export type ProvisionRequest = Static<typeof ProvisionRequestSchema>;

//#endregion

//#region --- WebSocket Types ---

export interface WebSocketAuthContext {
    userDid: string;
    appId: string; // App ID (URL or DID) that initiated the WebSocket connection
}

export interface WebSocketManagedContext extends WebSocketAuthContext {
    subscriptions: Set<string>; // Collections the user is subscribed to
}

export interface WebSocketClientMessage {
    action: "subscribe" | "unsubscribe";
    collection: string;
}

export type WebSocketServerMessage =
    | { status: "subscribed" | "unsubscribed" | "denied" | "not_subscribed"; collection: string; reason?: string }
    | { error: string }
    | { type: "update" | "delete"; collection: string; data: any }; // Consider typing 'data' more strictly

//#endregion

//#region --- Base & External Types ---

export type { DocumentInsertResponse, MaybeDocument };
export type ChangeWithDoc<TDocSchema extends TSchema> = nano.DatabaseChangesResultItem & {
    doc?: Static<TDocSchema> & MaybeDocument; // Ensure _id/_rev might be present
};

//#endregion
